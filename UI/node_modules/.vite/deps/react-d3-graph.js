import {
  init_src as init_src4,
  src_exports as src_exports4
} from "./chunk-NCYY7B2V.js";
import {
  init_src2 as init_src,
  src_exports
} from "./chunk-DQ7WFJU5.js";
import {
  init_src2,
  init_src3,
  init_src8 as init_src5,
  src_exports as src_exports2,
  src_exports2 as src_exports3,
  src_exports3 as src_exports5
} from "./chunk-CK55IO32.js";
import "./chunk-D7QNI5OO.js";
import {
  require_react
} from "./chunk-LL6ON2IQ.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-CEQRFMJQ.js";

// node_modules/react-d3-graph/lib/const.js
var require_const = __commonJS({
  "node_modules/react-d3-graph/lib/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      SYMBOLS: {
        CIRCLE: "circle",
        CROSS: "cross",
        DIAMOND: "diamond",
        SQUARE: "square",
        STAR: "star",
        TRIANGLE: "triangle",
        WYE: "wye"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/components/graph/graph.const.js
var require_graph_const = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/graph.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _const = _interopRequireDefault(require_const());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var _default = _objectSpread({
      COORDS_SEPARATOR: ",",
      FORCE_X: 0.06,
      FORCE_Y: 0.06,
      GRAPH_CONTAINER_ID: "graph-container-zoomable",
      GRAPH_WRAPPER_ID: "graph-wrapper",
      KEYWORDS: {
        SAME: "SAME"
      },
      LINK_CLASS_NAME: "link",
      NODE_CLASS_NAME: "node",
      TTL_DOUBLE_CLICK_IN_MS: 300
    }, _const["default"]);
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/components/graph/graph.config.js
var require_graph_config = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/graph.config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      automaticRearrangeAfterDropNode: false,
      collapsible: false,
      directed: false,
      focusAnimationDuration: 0.75,
      focusZoom: 1,
      freezeAllDragEvents: false,
      height: 400,
      highlightDegree: 1,
      highlightOpacity: 1,
      linkHighlightBehavior: false,
      maxZoom: 8,
      minZoom: 0.1,
      initialZoom: null,
      nodeHighlightBehavior: false,
      panAndZoom: false,
      staticGraph: false,
      staticGraphWithDragAndDrop: false,
      width: 800,
      d3: {
        alphaTarget: 0.05,
        gravity: -100,
        linkLength: 100,
        linkStrength: 1,
        disableLinkForce: false
      },
      node: {
        color: "#d3d3d3",
        fontColor: "black",
        fontSize: 8,
        fontWeight: "normal",
        highlightColor: "SAME",
        highlightFontSize: 8,
        highlightFontWeight: "normal",
        highlightStrokeColor: "SAME",
        highlightStrokeWidth: "SAME",
        labelProperty: "id",
        labelPosition: null,
        mouseCursor: "pointer",
        opacity: 1,
        renderLabel: true,
        size: 200,
        strokeColor: "none",
        strokeWidth: 1.5,
        svg: "",
        symbolType: "circle",
        viewGenerator: null
      },
      link: {
        color: "#d3d3d3",
        fontColor: "black",
        fontSize: 8,
        fontWeight: "normal",
        highlightColor: "SAME",
        highlightFontSize: 8,
        highlightFontWeight: "normal",
        labelProperty: "label",
        mouseCursor: "pointer",
        opacity: 1,
        renderLabel: false,
        semanticStrokeWidth: false,
        strokeWidth: 1.5,
        markerHeight: 6,
        markerWidth: 6,
        type: "STRAIGHT",
        strokeDasharray: 0,
        strokeDashoffset: 0,
        strokeLinecap: "butt"
      }
    };
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/err.js
var require_err = __commonJS({
  "node_modules/react-d3-graph/lib/err.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = {
      GRAPH_NO_ID_PROP: "id prop not defined! id property is mandatory and it should be unique.",
      INSUFFICIENT_LINKS: "you are passing invalid data to react-d3-graph. You must include a links array, even if empty, in the data object you're passing down to the <Graph> component.",
      INVALID_LINKS: "you provided a invalid links data structure. Links source and target attributes must point to an existent node",
      INSUFFICIENT_DATA: "you have not provided enough data for react-d3-graph to render something. You need to provide at least one node",
      INVALID_LINK_VALUE: "links 'value' attribute must be of type number"
    };
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/utils.js
var require_utils = __commonJS({
  "node_modules/react-d3-graph/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isDeepEqual = isDeepEqual;
    exports.isEmptyObject = isEmptyObject;
    exports.deepClone = deepClone;
    exports.merge = merge;
    exports.pick = pick;
    exports.antiPick = antiPick;
    exports.debounce = debounce;
    exports.throwErr = throwErr;
    exports.logError = logError;
    exports.logWarning = logWarning;
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    var MAX_DEPTH = 20;
    function _isPropertyNestedObject(o, k) {
      return !!o && Object.prototype.hasOwnProperty.call(o, k) && _typeof(o[k]) === "object" && o[k] !== null && !isEmptyObject(o[k]);
    }
    function isDeepEqual(o1, o2) {
      var _depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var diffs = [];
      if (_depth === 0 && o1 === o2) {
        return true;
      }
      if (isEmptyObject(o1) && !isEmptyObject(o2) || !isEmptyObject(o1) && isEmptyObject(o2)) {
        return false;
      }
      var o1Keys = Object.keys(o1);
      var o2Keys = Object.keys(o2);
      if (o1Keys.length !== o2Keys.length) {
        return false;
      }
      for (var _i = 0, _o1Keys = o1Keys; _i < _o1Keys.length; _i++) {
        var k = _o1Keys[_i];
        var nestedO = _isPropertyNestedObject(o1, k) && _isPropertyNestedObject(o2, k);
        if (nestedO && _depth < MAX_DEPTH) {
          diffs.push(isDeepEqual(o1[k], o2[k], _depth + 1));
        } else {
          var r = isEmptyObject(o1[k]) && isEmptyObject(o2[k]) || Object.prototype.hasOwnProperty.call(o2, k) && o2[k] === o1[k];
          diffs.push(r);
          if (!r) {
            break;
          }
        }
      }
      return diffs.indexOf(false) === -1;
    }
    function isEmptyObject(o) {
      return !!o && _typeof(o) === "object" && !Object.keys(o).length;
    }
    function deepClone(o) {
      var _clone = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var oKeys = Object.keys(o);
      for (var _i2 = 0, _oKeys = oKeys; _i2 < _oKeys.length; _i2++) {
        var k = _oKeys[_i2];
        var nested = _isPropertyNestedObject(o, k);
        _clone[k] = nested && _depth < MAX_DEPTH ? deepClone(o[k], {}, _depth + 1) : o[k];
      }
      return _clone;
    }
    function merge() {
      var o1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var o2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _depth = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
      var o = {};
      if (Object.keys(o1 || {}).length === 0) {
        return o2 && !isEmptyObject(o2) ? o2 : {};
      }
      for (var _i3 = 0, _Object$keys = Object.keys(o1); _i3 < _Object$keys.length; _i3++) {
        var k = _Object$keys[_i3];
        var nestedO = !!(o2[k] && _typeof(o2[k]) === "object" && _typeof(o1[k]) === "object" && _depth < MAX_DEPTH);
        if (nestedO) {
          (function() {
            var r = merge(o1[k], o2[k], _depth + 1);
            o[k] = Object.prototype.hasOwnProperty.call(o1[k], "length") && Object.prototype.hasOwnProperty.call(o2[k], "length") ? Object.keys(r).map(function(rk) {
              return r[rk];
            }) : r;
          })();
        } else {
          o[k] = Object.prototype.hasOwnProperty.call(o2, k) ? o2[k] : o1[k];
        }
      }
      return o;
    }
    function pick(o) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      return props.reduce(function(acc, k) {
        if (Object.prototype.hasOwnProperty.call(o, k)) {
          acc[k] = o[k];
        }
        return acc;
      }, {});
    }
    function antiPick(o) {
      var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var wanted = Object.keys(o).filter(function(k) {
        return !props.includes(k);
      });
      return pick(o, wanted);
    }
    function debounce(fn, time) {
      var timer;
      return function exec() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var later = function later2() {
          clearTimeout(timer);
          fn.apply(void 0, args);
        };
        timer && clearTimeout(timer);
        timer = setTimeout(later, time);
      };
    }
    function buildFormattedErrorMessage() {
      var component = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "N/A";
      var msg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "N/A";
      return "react-d3-graph :: ".concat(component, " :: ").concat(msg);
    }
    function throwErr(component, msg) {
      throw Error(buildFormattedErrorMessage(component, msg));
    }
    function logError(component, msg) {
      console.error(buildFormattedErrorMessage(component, msg));
    }
    function logWarning(component, msg) {
      var warning = "react-d3-graph :: ".concat(component, " :: ").concat(msg);
      console.warn(warning);
    }
  }
});

// node_modules/react-d3-graph/lib/components/graph/graph.helper.js
var require_graph_helper = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/graph.helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.checkForGraphConfigChanges = checkForGraphConfigChanges;
    exports.checkForGraphElementsChanges = checkForGraphElementsChanges;
    exports.getCenterAndZoomTransformation = getCenterAndZoomTransformation;
    exports.getId = getId;
    exports.initializeGraphState = initializeGraphState;
    exports.updateNodeHighlightedValue = updateNodeHighlightedValue;
    exports.getNormalizedNodeCoordinates = getNormalizedNodeCoordinates;
    exports.initializeNodes = initializeNodes;
    var _d3Force = (init_src4(), __toCommonJS(src_exports4));
    var _d3Selection = (init_src2(), __toCommonJS(src_exports2));
    var _d3Zoom = (init_src5(), __toCommonJS(src_exports5));
    var _graph2 = _interopRequireDefault(require_graph_const());
    var _graph3 = _interopRequireDefault(require_graph_config());
    var _err = _interopRequireDefault(require_err());
    var _utils = require_utils();
    var _collapse = require_collapse_helper();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var NODE_PROPS_WHITELIST = ["id", "highlighted", "x", "y", "index", "vy", "vx"];
    var LINK_PROPS_WHITELIST = ["index", "source", "target", "isHidden"];
    function _createForceSimulation(width, height, gravity) {
      var frx = (0, _d3Force.forceX)(width / 2).strength(_graph2["default"].FORCE_X);
      var fry = (0, _d3Force.forceY)(height / 2).strength(_graph2["default"].FORCE_Y);
      var forceStrength = gravity;
      return (0, _d3Force.forceSimulation)().force("charge", (0, _d3Force.forceManyBody)().strength(forceStrength)).force("x", frx).force("y", fry);
    }
    function _initializeLinks(graphLinks, config) {
      return graphLinks.reduce(function(links, l) {
        var source = getId(l.source);
        var target = getId(l.target);
        if (!links[source]) {
          links[source] = {};
        }
        if (!links[target]) {
          links[target] = {};
        }
        var value = config.collapsible && l.isHidden ? 0 : l.value || 1;
        links[source][target] = value;
        if (!config.directed) {
          links[target][source] = value;
        }
        return links;
      }, {});
    }
    function initializeNodes(graphNodes) {
      var nodes = {};
      var n = graphNodes.length;
      for (var i = 0; i < n; i++) {
        var node = graphNodes[i];
        node.highlighted = false;
        if (Object.prototype.hasOwnProperty.call(node, "fx")) {
          node.x = node.fx;
        } else if (!Object.prototype.hasOwnProperty.call(node, "x")) {
          node.x = 0;
        }
        if (Object.prototype.hasOwnProperty.call(node, "fy")) {
          node.y = node.fy;
        } else if (!Object.prototype.hasOwnProperty.call(node, "y")) {
          node.y = 0;
        }
        nodes[node.id.toString()] = node;
      }
      return nodes;
    }
    function _mergeDataLinkWithD3Link(link, index) {
      var d3Links = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
      var config = arguments.length > 3 ? arguments[3] : void 0;
      var state = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
      var tmp = d3Links.find(function(l) {
        return l.source.id === link.source && l.target.id === link.target;
      });
      var d3Link = tmp && (0, _utils.pick)(tmp, LINK_PROPS_WHITELIST);
      var customProps = (0, _utils.antiPick)(link, ["source", "target"]);
      if (d3Link) {
        var toggledDirected = state.config && Object.prototype.hasOwnProperty.call(state.config, "directed") && config.directed !== state.config.directed;
        var refinedD3Link = _objectSpread({
          index
        }, d3Link, {}, customProps);
        if (toggledDirected) {
          return _objectSpread({}, refinedD3Link, {
            isHidden: false
          });
        }
        return config.collapsible ? refinedD3Link : _objectSpread({}, refinedD3Link, {
          isHidden: false
        });
      }
      var highlighted = false;
      var source = {
        id: link.source,
        highlighted
      };
      var target = {
        id: link.target,
        highlighted
      };
      return _objectSpread({
        index,
        source,
        target
      }, customProps);
    }
    function _tagOrphanNodes(nodes, linksMatrix) {
      return Object.keys(nodes).reduce(function(acc, nodeId) {
        var _computeNodeDegree = (0, _collapse.computeNodeDegree)(nodeId, linksMatrix), inDegree = _computeNodeDegree.inDegree, outDegree = _computeNodeDegree.outDegree;
        var node = nodes[nodeId];
        var taggedNode = inDegree === 0 && outDegree === 0 ? _objectSpread({}, node, {
          _orphan: true
        }) : node;
        acc[nodeId] = taggedNode;
        return acc;
      }, {});
    }
    function _validateGraphData(data) {
      if (!data.nodes || !data.nodes.length) {
        (0, _utils.logWarning)("Graph", _err["default"].INSUFFICIENT_DATA);
        data.nodes = [];
      }
      if (!data.links) {
        (0, _utils.logWarning)("Graph", _err["default"].INSUFFICIENT_LINKS);
        data.links = [];
      }
      var n = data.links.length;
      var _loop = function _loop2(i2) {
        var l = data.links[i2];
        if (!data.nodes.find(function(n2) {
          return n2.id === l.source;
        })) {
          (0, _utils.throwErr)("Graph", "".concat(_err["default"].INVALID_LINKS, ' - "').concat(l.source, '" is not a valid source node id'));
        }
        if (!data.nodes.find(function(n2) {
          return n2.id === l.target;
        })) {
          (0, _utils.throwErr)("Graph", "".concat(_err["default"].INVALID_LINKS, ' - "').concat(l.target, '" is not a valid target node id'));
        }
        if (l && l.value !== void 0 && typeof l.value !== "number") {
          (0, _utils.throwErr)("Graph", "".concat(_err["default"].INVALID_LINK_VALUE, ' - found in link with source "').concat(l.source, '" and target "').concat(l.target, '"'));
        }
      };
      for (var i = 0; i < n; i++) {
        _loop(i);
      }
    }
    var NODE_PROPERTIES_DISCARD_TO_COMPARE = ["x", "y", "vx", "vy", "index"];
    function _pickId(o) {
      return (0, _utils.pick)(o, ["id"]);
    }
    function _pickSourceAndTarget(o) {
      return (0, _utils.pick)(o, ["source", "target"]);
    }
    function checkForGraphElementsChanges(nextProps, currentState) {
      var nextNodes = nextProps.data.nodes.map(function(n) {
        return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);
      });
      var nextLinks = nextProps.data.links;
      var stateD3Nodes = currentState.d3Nodes.map(function(n) {
        return (0, _utils.antiPick)(n, NODE_PROPERTIES_DISCARD_TO_COMPARE);
      });
      var stateD3Links = currentState.d3Links.map(function(l) {
        return {
          source: getId(l.source),
          target: getId(l.target)
        };
      });
      var graphElementsUpdated = !((0, _utils.isDeepEqual)(nextNodes, stateD3Nodes) && (0, _utils.isDeepEqual)(nextLinks, stateD3Links));
      var newGraphElements = nextNodes.length !== stateD3Nodes.length || nextLinks.length !== stateD3Links.length || !(0, _utils.isDeepEqual)(nextNodes.map(_pickId), stateD3Nodes.map(_pickId)) || !(0, _utils.isDeepEqual)(nextLinks.map(_pickSourceAndTarget), stateD3Links.map(_pickSourceAndTarget));
      return {
        graphElementsUpdated,
        newGraphElements
      };
    }
    function checkForGraphConfigChanges(nextProps, currentState) {
      var newConfig = nextProps.config || {};
      var configUpdated = newConfig && !(0, _utils.isEmptyObject)(newConfig) && !(0, _utils.isDeepEqual)(newConfig, currentState.config);
      var d3ConfigUpdated = newConfig && newConfig.d3 && !(0, _utils.isDeepEqual)(newConfig.d3, currentState.config.d3);
      return {
        configUpdated,
        d3ConfigUpdated
      };
    }
    function getCenterAndZoomTransformation(d3Node, config, containerElId) {
      if (!d3Node) {
        return;
      }
      var width = config.width, height = config.height, focusZoom = config.focusZoom;
      var selector = (0, _d3Selection.select)("#".concat(containerElId));
      selector.call((0, _d3Zoom.zoom)().transform, _d3Zoom.zoomIdentity.translate(width / 2, height / 2).scale(focusZoom).translate(-d3Node.x, -d3Node.y));
      return "\n    translate(".concat(width / 2, ", ").concat(height / 2, ")\n    scale(").concat(focusZoom, ")\n    translate(").concat(-d3Node.x, ", ").concat(-d3Node.y, ")\n  ");
    }
    function getId(sot) {
      return sot.id !== void 0 && sot.id !== null ? sot.id : sot;
    }
    function initializeGraphState(_ref, state) {
      var data = _ref.data, id = _ref.id, config = _ref.config;
      _validateGraphData(data);
      var graph;
      if (state && state.nodes) {
        graph = {
          nodes: data.nodes.map(function(n) {
            return state.nodes[n.id] ? _objectSpread({}, n, {}, (0, _utils.pick)(state.nodes[n.id], NODE_PROPS_WHITELIST)) : _objectSpread({}, n);
          }),
          links: data.links.map(function(l, index) {
            return _mergeDataLinkWithD3Link(l, index, state && state.d3Links, config, state);
          })
        };
      } else {
        graph = {
          nodes: data.nodes.map(function(n) {
            return _objectSpread({}, n);
          }),
          links: data.links.map(function(l) {
            return _objectSpread({}, l);
          })
        };
      }
      var newConfig = _objectSpread({}, (0, _utils.merge)(_graph3["default"], config || {})), links = _initializeLinks(graph.links, newConfig), nodes = _tagOrphanNodes(initializeNodes(graph.nodes), links);
      var _graph = graph, d3Nodes = _graph.nodes, d3Links = _graph.links;
      var formatedId = id.replace(/ /g, "_");
      var simulation = _createForceSimulation(newConfig.width, newConfig.height, newConfig.d3 && newConfig.d3.gravity);
      var minZoom = newConfig.minZoom, maxZoom = newConfig.maxZoom, focusZoom = newConfig.focusZoom;
      if (focusZoom > maxZoom) {
        newConfig.focusZoom = maxZoom;
      } else if (focusZoom < minZoom) {
        newConfig.focusZoom = minZoom;
      }
      return {
        id: formatedId,
        config: newConfig,
        links,
        d3Links,
        nodes,
        d3Nodes,
        highlightedNode: "",
        simulation,
        newGraphElements: false,
        configUpdated: false,
        transform: 1,
        draggedNode: null
      };
    }
    function updateNodeHighlightedValue(nodes, links, config, id) {
      var value = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
      var highlightedNode = value ? id : "";
      var node = _objectSpread({}, nodes[id], {
        highlighted: value
      });
      var updatedNodes = _objectSpread({}, nodes, _defineProperty({}, id, node));
      if (links[id] && config.highlightDegree !== 0) {
        updatedNodes = Object.keys(links[id]).reduce(function(acc, linkId) {
          var updatedNode = _objectSpread({}, updatedNodes[linkId], {
            highlighted: value
          });
          acc[linkId] = updatedNode;
          return acc;
        }, updatedNodes);
      }
      return {
        nodes: updatedNodes,
        highlightedNode
      };
    }
    function normalize(vector) {
      var norm = Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
      return norm === 0 ? vector : {
        x: vector.x / norm,
        y: vector.y / norm
      };
    }
    var SYMBOLS_WITH_OPTIMIZED_POSITIONING = /* @__PURE__ */ new Set([_graph2["default"].SYMBOLS.CIRCLE]);
    function getNormalizedNodeCoordinates(_ref2, nodes, config, strokeWidth) {
      var _config$node, _config$node2, _config$node3;
      var sourceId = _ref2.sourceId, targetId = _ref2.targetId, _ref2$sourceCoords = _ref2.sourceCoords, sourceCoords = _ref2$sourceCoords === void 0 ? {} : _ref2$sourceCoords, _ref2$targetCoords = _ref2.targetCoords, targetCoords = _ref2$targetCoords === void 0 ? {} : _ref2$targetCoords;
      var sourceNode = nodes === null || nodes === void 0 ? void 0 : nodes[sourceId];
      var targetNode = nodes === null || nodes === void 0 ? void 0 : nodes[targetId];
      if (!sourceNode || !targetNode) {
        return {
          sourceCoords,
          targetCoords
        };
      }
      if (((_config$node = config.node) === null || _config$node === void 0 ? void 0 : _config$node.viewGenerator) || (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.viewGenerator) || (targetNode === null || targetNode === void 0 ? void 0 : targetNode.viewGenerator)) {
        return {
          sourceCoords,
          targetCoords
        };
      }
      var sourceSymbolType = sourceNode.symbolType || ((_config$node2 = config.node) === null || _config$node2 === void 0 ? void 0 : _config$node2.symbolType);
      var targetSymbolType = targetNode.symbolType || ((_config$node3 = config.node) === null || _config$node3 === void 0 ? void 0 : _config$node3.symbolType);
      if (!SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(sourceSymbolType) && !SYMBOLS_WITH_OPTIMIZED_POSITIONING.has(targetSymbolType)) {
        return {
          sourceCoords,
          targetCoords
        };
      }
      var x1 = sourceCoords.x, y1 = sourceCoords.y;
      var x2 = targetCoords.x, y2 = targetCoords.y;
      var directionVector = normalize({
        x: x2 - x1,
        y: y2 - y1
      });
      switch (sourceSymbolType) {
        case _graph2["default"].SYMBOLS.CIRCLE: {
          var sourceNodeSize = (sourceNode === null || sourceNode === void 0 ? void 0 : sourceNode.size) || config.node.size;
          sourceNodeSize = Math.sqrt(sourceNodeSize / Math.PI) * 0.95;
          x1 += sourceNodeSize * directionVector.x;
          y1 += sourceNodeSize * directionVector.y;
          break;
        }
      }
      switch (targetSymbolType) {
        case _graph2["default"].SYMBOLS.CIRCLE: {
          var _config$link, _config$link2;
          var strokeSize = strokeWidth * Math.min(((_config$link = config.link) === null || _config$link === void 0 ? void 0 : _config$link.markerWidth) || 0, ((_config$link2 = config.link) === null || _config$link2 === void 0 ? void 0 : _config$link2.markerHeight) || 0);
          var targetNodeSize = (targetNode === null || targetNode === void 0 ? void 0 : targetNode.size) || config.node.size;
          targetNodeSize = Math.sqrt(targetNodeSize / Math.PI) * 0.95;
          x2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.x;
          y2 -= (targetNodeSize + (config.directed ? strokeSize : 0)) * directionVector.y;
          break;
        }
      }
      return {
        sourceCoords: {
          x: x1,
          y: y1
        },
        targetCoords: {
          x: x2,
          y: y2
        }
      };
    }
  }
});

// node_modules/react-d3-graph/lib/components/graph/collapse.helper.js
var require_collapse_helper = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/collapse.helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.computeNodeDegree = computeNodeDegree;
    exports.getTargetLeafConnections = getTargetLeafConnections;
    exports.isNodeVisible = isNodeVisible;
    exports.toggleLinksConnections = toggleLinksConnections;
    exports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;
    var _graph = require_graph_helper();
    var _utils = require_utils();
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _isLeafDirected(inDegree, outDegree) {
      return inDegree <= 1 && outDegree < 1;
    }
    function _isLeafNotDirected(inDegree, outDegree) {
      return inDegree <= 1 && outDegree <= 1;
    }
    function _isLeaf(nodeId, linksMatrix, directed) {
      var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix), inDegree = _computeNodeDegree.inDegree, outDegree = _computeNodeDegree.outDegree;
      var fn = directed ? _isLeafDirected : _isLeafNotDirected;
      return fn(inDegree, outDegree);
    }
    function computeNodeDegree(nodeId) {
      var linksMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return Object.keys(linksMatrix).reduce(function(acc, source) {
        if (!linksMatrix[source]) {
          return acc;
        }
        var currentNodeConnections = Object.keys(linksMatrix[source]);
        return currentNodeConnections.reduce(function(_acc, target) {
          if (nodeId === source) {
            _acc.outDegree += linksMatrix[nodeId][target];
          }
          if (nodeId === target) {
            _acc.inDegree += linksMatrix[source][nodeId];
          }
          return _acc;
        }, acc);
      }, {
        inDegree: 0,
        outDegree: 0
      });
    }
    function getTargetLeafConnections(rootNodeId) {
      var linksMatrix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var _ref = arguments.length > 2 ? arguments[2] : void 0, directed = _ref.directed;
      var rootConnectionsNodesIds = linksMatrix[rootNodeId] ? Object.keys(linksMatrix[rootNodeId]) : [];
      return rootConnectionsNodesIds.reduce(function(leafConnections, target) {
        if (_isLeaf(target, linksMatrix, directed)) {
          leafConnections.push({
            source: rootNodeId,
            target
          });
        }
        return leafConnections;
      }, []);
    }
    function isNodeVisible(nodeId, nodes, linksMatrix) {
      var node = nodes[nodeId];
      if (!node) {
        if (true) {
          (0, _utils.logError)("graph/collapse.helper", "Trying to check if node ".concat(nodeId, " is visible but its not present in nodes: "), nodes);
        }
        return false;
      }
      if (nodes[nodeId]._orphan) {
        return true;
      }
      var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix), inDegree = _computeNodeDegree2.inDegree, outDegree = _computeNodeDegree2.outDegree;
      return inDegree > 0 || outDegree > 0;
    }
    function toggleLinksConnections(d3Links, connectionMatrix) {
      return d3Links.map(function(d3Link) {
        var source = d3Link.source, target = d3Link.target;
        var sourceId = (0, _graph.getId)(source);
        var targetId = (0, _graph.getId)(target);
        var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];
        var isHidden = !connection;
        return _objectSpread({}, d3Link, {
          isHidden
        });
      });
    }
    function toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {
      var directed = _ref2.directed;
      return connections.reduce(function(newMatrix, link) {
        if (!newMatrix[link.source]) {
          newMatrix[link.source] = {};
        }
        if (!newMatrix[link.source][link.target]) {
          newMatrix[link.source][link.target] = 0;
        }
        var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;
        newMatrix[link.source][link.target] = newConnectionValue;
        if (!directed) {
          newMatrix[link.target][link.source] = newConnectionValue;
        }
        return newMatrix;
      }, _objectSpread({}, linksMatrix));
    }
  }
});

// node_modules/react-d3-graph/lib/components/marker/marker.const.js
var require_marker_const = __commonJS({
  "node_modules/react-d3-graph/lib/components/marker/marker.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SIZES = exports.MARKERS = exports.MARKER_SMALL_SIZE = exports.MARKER_MEDIUM_OFFSET = exports.MARKER_LARGE_OFFSET = exports.HIGHLIGHTED = void 0;
    var HIGHLIGHTED = "H";
    exports.HIGHLIGHTED = HIGHLIGHTED;
    var MARKER_SMALL_SIZE = 16;
    exports.MARKER_SMALL_SIZE = MARKER_SMALL_SIZE;
    var MARKER_MEDIUM_OFFSET = 2;
    exports.MARKER_MEDIUM_OFFSET = MARKER_MEDIUM_OFFSET;
    var MARKER_LARGE_OFFSET = 4;
    exports.MARKER_LARGE_OFFSET = MARKER_LARGE_OFFSET;
    var MARKERS = {
      MARKER_S: "marker-small",
      MARKER_SH: "marker-small-highlighted",
      MARKER_M: "marker-medium",
      MARKER_MH: "marker-medium-highlighted",
      MARKER_L: "marker-large",
      MARKER_LH: "marker-large-highlighted"
    };
    exports.MARKERS = MARKERS;
    var SIZES = {
      S: "S",
      M: "M",
      L: "L"
    };
    exports.SIZES = SIZES;
  }
});

// node_modules/react-d3-graph/lib/components/link/Link.js
var require_Link = __commonJS({
  "node_modules/react-d3-graph/lib/components/link/Link.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Link = function(_React$Component) {
      _inherits(Link2, _React$Component);
      function Link2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, Link2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Link2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_this), "handleOnClickLink", function() {
          return _this.props.onClickLink && _this.props.onClickLink(_this.props.source, _this.props.target);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnRightClickLink", function(event) {
          return _this.props.onRightClickLink && _this.props.onRightClickLink(event, _this.props.source, _this.props.target);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnMouseOverLink", function() {
          return _this.props.onMouseOverLink && _this.props.onMouseOverLink(_this.props.source, _this.props.target);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnMouseOutLink", function() {
          return _this.props.onMouseOutLink && _this.props.onMouseOutLink(_this.props.source, _this.props.target);
        });
        return _this;
      }
      _createClass(Link2, [{
        key: "render",
        value: function render() {
          var lineStyle = {
            strokeWidth: this.props.strokeWidth,
            stroke: this.props.stroke,
            opacity: this.props.opacity,
            fill: "none",
            cursor: this.props.mouseCursor,
            strokeDasharray: this.props.strokeDasharray,
            strokeDashoffset: this.props.strokeDasharray,
            strokeLinecap: this.props.strokeLinecap
          };
          var lineProps = {
            className: this.props.className,
            d: this.props.d,
            onClick: this.handleOnClickLink,
            onContextMenu: this.handleOnRightClickLink,
            onMouseOut: this.handleOnMouseOutLink,
            onMouseOver: this.handleOnMouseOverLink,
            style: lineStyle
          };
          if (this.props.markerId) {
            lineProps.markerEnd = "url(#".concat(this.props.markerId, ")");
          }
          var _this$props = this.props, label = _this$props.label, id = _this$props.id;
          var textProps = {
            dy: -1,
            style: {
              fill: this.props.fontColor,
              fontSize: this.props.fontSize,
              fontWeight: this.props.fontWeight
            }
          };
          return _react["default"].createElement("g", null, _react["default"].createElement("path", _extends({}, lineProps, {
            id
          })), label && _react["default"].createElement("text", _extends({
            style: {
              textAnchor: "middle"
            }
          }, textProps), _react["default"].createElement("textPath", {
            href: "#".concat(id),
            startOffset: "50%"
          }, label)));
        }
      }]);
      return Link2;
    }(_react["default"].Component);
    exports["default"] = Link;
  }
});

// node_modules/react-d3-graph/lib/components/node/node.const.js
var require_node_const = __commonJS({
  "node_modules/react-d3-graph/lib/components/node/node.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _graph = _interopRequireDefault(require_graph_config());
    var _const = _interopRequireDefault(require_const());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var _default = _objectSpread({
      ARC: {
        START_ANGLE: 0,
        END_ANGLE: 2 * Math.PI
      },
      DEFAULT_NODE_SIZE: _graph["default"].node.size,
      NODE_LABEL_DX: ".90em",
      NODE_LABEL_DY: ".35em"
    }, _const["default"]);
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/components/node/node.helper.js
var require_node_helper = __commonJS({
  "node_modules/react-d3-graph/lib/components/node/node.helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _d3Shape = (init_src(), __toCommonJS(src_exports));
    var _node = _interopRequireDefault(require_node_const());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _convertTypeToD3Symbol(typeName) {
      switch (typeName) {
        case _node["default"].SYMBOLS.CIRCLE:
          return _d3Shape.symbolCircle;
        case _node["default"].SYMBOLS.CROSS:
          return _d3Shape.symbolCross;
        case _node["default"].SYMBOLS.DIAMOND:
          return _d3Shape.symbolDiamond;
        case _node["default"].SYMBOLS.SQUARE:
          return _d3Shape.symbolSquare;
        case _node["default"].SYMBOLS.STAR:
          return _d3Shape.symbolStar;
        case _node["default"].SYMBOLS.TRIANGLE:
          return _d3Shape.symbolTriangle;
        case _node["default"].SYMBOLS.WYE:
          return _d3Shape.symbolWye;
        default:
          return _d3Shape.symbolCircle;
      }
    }
    function buildSvgSymbol() {
      var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _node["default"].DEFAULT_NODE_SIZE;
      var symbolTypeDesc = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : _node["default"].SYMBOLS.CIRCLE;
      return (0, _d3Shape.symbol)().size(function() {
        return size;
      }).type(function() {
        return _convertTypeToD3Symbol(symbolTypeDesc);
      })();
    }
    function getLabelPlacementProps(dx, labelPosition) {
      switch (labelPosition) {
        case "right":
          return {
            dx: dx ? "".concat(dx) : _node["default"].NODE_LABEL_DX,
            dy: "0",
            dominantBaseline: "middle",
            textAnchor: "start"
          };
        case "left":
          return {
            dx: dx ? "".concat(-dx) : "-".concat(_node["default"].NODE_LABEL_DX),
            dy: "0",
            dominantBaseline: "middle",
            textAnchor: "end"
          };
        case "top":
          return {
            dx: "0",
            dy: dx ? "".concat(-dx) : "-".concat(_node["default"].NODE_LABEL_DX),
            dominantBaseline: "baseline",
            textAnchor: "middle"
          };
        case "bottom":
          return {
            dx: "0",
            dy: dx ? "".concat(dx) : _node["default"].NODE_LABEL_DX,
            dominantBaseline: "hanging",
            textAnchor: "middle"
          };
        case "center":
          return {
            dx: "0",
            dy: "0",
            dominantBaseline: "middle",
            textAnchor: "middle"
          };
        default:
          return {
            dx: dx ? "".concat(dx) : _node["default"].NODE_LABEL_DX,
            dy: _node["default"].NODE_LABEL_DY
          };
      }
    }
    var _default = {
      buildSvgSymbol,
      getLabelPlacementProps
    };
    exports["default"] = _default;
  }
});

// node_modules/react-d3-graph/lib/components/node/Node.js
var require_Node = __commonJS({
  "node_modules/react-d3-graph/lib/components/node/Node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _node = _interopRequireDefault(require_node_helper());
    var _node2 = _interopRequireDefault(require_node_const());
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Node = function(_React$Component) {
      _inherits(Node2, _React$Component);
      function Node2() {
        var _getPrototypeOf2;
        var _this;
        _classCallCheck(this, Node2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(Node2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        _defineProperty(_assertThisInitialized(_this), "handleOnClickNode", function() {
          return _this.props.onClickNode && _this.props.onClickNode(_this.props.id);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnRightClickNode", function(event) {
          return _this.props.onRightClickNode && _this.props.onRightClickNode(event, _this.props.id);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnMouseOverNode", function() {
          return _this.props.onMouseOverNode && _this.props.onMouseOverNode(_this.props.id);
        });
        _defineProperty(_assertThisInitialized(_this), "handleOnMouseOutNode", function() {
          return _this.props.onMouseOut && _this.props.onMouseOut(_this.props.id);
        });
        return _this;
      }
      _createClass(Node2, [{
        key: "render",
        value: function render() {
          var nodeProps = {
            cursor: this.props.cursor,
            onClick: this.handleOnClickNode,
            onContextMenu: this.handleOnRightClickNode,
            onMouseOut: this.handleOnMouseOutNode,
            onMouseOver: this.handleOnMouseOverNode,
            opacity: this.props.opacity
          };
          var textProps = _objectSpread({}, _node["default"].getLabelPlacementProps(this.props.dx, this.props.labelPosition), {
            fill: this.props.fontColor,
            fontSize: this.props.fontSize,
            fontWeight: this.props.fontWeight,
            opacity: this.props.opacity
          });
          var size = this.props.size;
          var isSizeNumericalValue = _typeof(size) !== "object";
          var gtx = this.props.cx, gty = this.props.cy, label = null, node = null;
          if (this.props.svg || this.props.viewGenerator) {
            var height = isSizeNumericalValue ? size / 10 : size.height / 10;
            var width = isSizeNumericalValue ? size / 10 : size.width / 10;
            var tx = width / 2;
            var ty = height / 2;
            var transform = "translate(".concat(tx, ",").concat(ty, ")");
            label = _react["default"].createElement("text", _extends({}, textProps, {
              transform
            }), this.props.label);
            if (this.props.viewGenerator && !this.props.overrideGlobalViewGenerator) {
              node = _react["default"].createElement("svg", _extends({}, nodeProps, {
                width,
                height
              }), _react["default"].createElement("foreignObject", {
                x: "0",
                y: "0",
                width: "100%",
                height: "100%"
              }, _react["default"].createElement("section", {
                style: {
                  height,
                  width,
                  backgroundColor: "transparent"
                }
              }, this.props.viewGenerator(this.props))));
            } else {
              node = _react["default"].createElement("image", _extends({}, nodeProps, {
                href: this.props.svg,
                width,
                height
              }));
            }
            gtx -= tx;
            gty -= ty;
          } else {
            if (!isSizeNumericalValue) {
              (0, _utils.logWarning)("node.size should be a number when not using custom nodes.");
              size = _node2["default"].DEFAULT_NODE_SIZE;
            }
            nodeProps.d = _node["default"].buildSvgSymbol(size, this.props.type);
            nodeProps.fill = this.props.fill;
            nodeProps.stroke = this.props.stroke;
            nodeProps.strokeWidth = this.props.strokeWidth;
            label = _react["default"].createElement("text", textProps, this.props.label);
            node = _react["default"].createElement("path", nodeProps);
          }
          var gProps = {
            className: this.props.className,
            cx: this.props.cx,
            cy: this.props.cy,
            id: this.props.id,
            transform: "translate(".concat(gtx, ",").concat(gty, ")")
          };
          return _react["default"].createElement("g", gProps, node, this.props.renderLabel && label);
        }
      }]);
      return Node2;
    }(_react["default"].Component);
    exports["default"] = Node;
  }
});

// node_modules/react-d3-graph/lib/components/marker/Marker.js
var require_Marker = __commonJS({
  "node_modules/react-d3-graph/lib/components/marker/Marker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    var Marker = function(_React$Component) {
      _inherits(Marker2, _React$Component);
      function Marker2() {
        _classCallCheck(this, Marker2);
        return _possibleConstructorReturn(this, _getPrototypeOf(Marker2).apply(this, arguments));
      }
      _createClass(Marker2, [{
        key: "render",
        value: function render() {
          return _react["default"].createElement("marker", {
            className: "marker",
            id: this.props.id,
            viewBox: "0 -5 10 10",
            refX: this.props.refX,
            refY: "0",
            markerWidth: this.props.markerWidth,
            markerHeight: this.props.markerHeight,
            orient: "auto",
            fill: this.props.fill
          }, _react["default"].createElement("path", {
            d: "M0,-5L10,0L0,5"
          }));
        }
      }]);
      return Marker2;
    }(_react["default"].Component);
    exports["default"] = Marker;
  }
});

// node_modules/react-d3-graph/lib/components/link/link.const.js
var require_link_const = __commonJS({
  "node_modules/react-d3-graph/lib/components/link/link.const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LINE_TYPES = void 0;
    var LINE_TYPES = {
      STRAIGHT: "STRAIGHT",
      CURVE_SMOOTH: "CURVE_SMOOTH",
      CURVE_FULL: "CURVE_FULL"
    };
    exports.LINE_TYPES = LINE_TYPES;
  }
});

// node_modules/react-d3-graph/lib/components/link/link.helper.js
var require_link_helper = __commonJS({
  "node_modules/react-d3-graph/lib/components/link/link.helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildLinkPathDefinition = buildLinkPathDefinition;
    var _link = require_link_const();
    var _RADIUS_STRATEGIES;
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }
    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]")
        return Array.from(iter);
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      }
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function straightLineRadius() {
      return 0;
    }
    function smoothCurveRadius(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    }
    function fullCurveRadius() {
      return 1;
    }
    var RADIUS_STRATEGIES = (_RADIUS_STRATEGIES = {}, _defineProperty(_RADIUS_STRATEGIES, _link.LINE_TYPES.STRAIGHT, straightLineRadius), _defineProperty(_RADIUS_STRATEGIES, _link.LINE_TYPES.CURVE_SMOOTH, smoothCurveRadius), _defineProperty(_RADIUS_STRATEGIES, _link.LINE_TYPES.CURVE_FULL, fullCurveRadius), _RADIUS_STRATEGIES);
    function getRadiusStrategy(type) {
      return RADIUS_STRATEGIES[type] || RADIUS_STRATEGIES[_link.LINE_TYPES.STRAIGHT];
    }
    function buildLinkPathDefinition() {
      var sourceCoords = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var targetCoords = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : _link.LINE_TYPES.STRAIGHT;
      var breakPoints = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : [];
      var sx = sourceCoords.x, sy = sourceCoords.y;
      var validType = _link.LINE_TYPES[type] || _link.LINE_TYPES.STRAIGHT;
      var calcRadiusFn = getRadiusStrategy(validType);
      var restOfLinkPoints = [].concat(_toConsumableArray(breakPoints), [targetCoords]);
      var restOfLinkPath = restOfLinkPoints.map(function(_ref, i) {
        var x = _ref.x, y = _ref.y;
        var _ref2 = i > 0 ? restOfLinkPoints[i - 1] : sourceCoords, px = _ref2.x, py = _ref2.y;
        var radius = calcRadiusFn(px, py, x, y);
        return " A".concat(radius, ",").concat(radius, " 0 0,1 ").concat(x, ",").concat(y);
      }).join("");
      return "M".concat(sx, ",").concat(sy).concat(restOfLinkPath);
    }
  }
});

// node_modules/react-d3-graph/lib/components/marker/marker.helper.js
var require_marker_helper = __commonJS({
  "node_modules/react-d3-graph/lib/components/marker/marker.helper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getMarkerSize = getMarkerSize;
    exports.getMarkerId = void 0;
    var _marker = require_marker_const();
    var _graph = _interopRequireDefault(require_graph_const());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _markerKeyBuilder(size, highlighted) {
      return "MARKER_".concat(size).concat(highlighted);
    }
    function _getMarkerSize(transform, mMax, lMax) {
      if (transform < mMax) {
        return _marker.SIZES.S;
      } else if (transform >= mMax && transform < lMax) {
        return _marker.SIZES.M;
      } else {
        return _marker.SIZES.L;
      }
    }
    function _computeMarkerId(highlight, transform, _ref) {
      var maxZoom = _ref.maxZoom;
      var mMax = maxZoom / 4;
      var lMax = maxZoom / 2;
      var size = _getMarkerSize(transform, mMax, lMax);
      var highlighted = highlight ? _marker.HIGHLIGHTED : "";
      var markerKey = _markerKeyBuilder(size, highlighted);
      return _marker.MARKERS[markerKey];
    }
    function _memoizedComputeMarkerId() {
      var cache = {};
      return function(highlight, transform, _ref2) {
        var maxZoom = _ref2.maxZoom;
        var cacheKey = "".concat(highlight, ";").concat(transform, ";").concat(maxZoom);
        if (cache[cacheKey]) {
          return cache[cacheKey];
        }
        var markerId = _computeMarkerId(highlight, transform, {
          maxZoom
        });
        cache[cacheKey] = markerId;
        return markerId;
      };
    }
    var getMarkerId = _memoizedComputeMarkerId();
    exports.getMarkerId = getMarkerId;
    function getMarkerSize(config) {
      var small = _marker.MARKER_SMALL_SIZE;
      var medium = small + _marker.MARKER_MEDIUM_OFFSET * config.maxZoom / 3;
      var large = small + _marker.MARKER_LARGE_OFFSET * config.maxZoom / 3;
      if (config.node && !config.node.viewGenerator) {
        switch (config.node.symbolType) {
          case _graph["default"].SYMBOLS.CIRCLE:
            small = 0;
            medium = 0;
            large = 0;
            break;
        }
      }
      return {
        small,
        medium,
        large
      };
    }
  }
});

// node_modules/react-d3-graph/lib/components/graph/graph.builder.js
var require_graph_builder = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/graph.builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildLinkProps = buildLinkProps;
    exports.buildNodeProps = buildNodeProps;
    var _graph = _interopRequireDefault(require_graph_const());
    var _link = require_link_helper();
    var _marker = require_marker_helper();
    var _graph2 = require_graph_helper();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _getNodeOpacity(node, highlightedNode, highlightedLink, config) {
      var highlight = node.highlighted || node.id === (highlightedLink && highlightedLink.source) || node.id === (highlightedLink && highlightedLink.target);
      var someLinkHighlighted = highlightedLink && highlightedLink.source && highlightedLink.target;
      var someNodeHighlighted = !!(highlightedNode || someLinkHighlighted);
      var opacity;
      if (someNodeHighlighted && config.highlightDegree === 0) {
        opacity = highlight ? config.node.opacity : config.highlightOpacity;
      } else if (someNodeHighlighted) {
        opacity = highlight ? config.node.opacity : config.highlightOpacity;
      } else {
        opacity = node.opacity || config.node.opacity;
      }
      return opacity;
    }
    function buildLinkProps(link, nodes, links, config, linkCallbacks, highlightedNode, highlightedLink, transform) {
      var _nodes$source, _nodes$source2, _nodes$target, _nodes$target2;
      var source = link.source, target = link.target;
      var x1 = (nodes === null || nodes === void 0 ? void 0 : (_nodes$source = nodes[source]) === null || _nodes$source === void 0 ? void 0 : _nodes$source.x) || 0;
      var y1 = (nodes === null || nodes === void 0 ? void 0 : (_nodes$source2 = nodes[source]) === null || _nodes$source2 === void 0 ? void 0 : _nodes$source2.y) || 0;
      var x2 = (nodes === null || nodes === void 0 ? void 0 : (_nodes$target = nodes[target]) === null || _nodes$target === void 0 ? void 0 : _nodes$target.x) || 0;
      var y2 = (nodes === null || nodes === void 0 ? void 0 : (_nodes$target2 = nodes[target]) === null || _nodes$target2 === void 0 ? void 0 : _nodes$target2.y) || 0;
      var type = link.type || config.link.type;
      var mainNodeParticipates = false;
      switch (config.highlightDegree) {
        case 0:
          break;
        case 2:
          mainNodeParticipates = true;
          break;
        default:
          mainNodeParticipates = source === highlightedNode || target === highlightedNode;
          break;
      }
      var guiltyNode = mainNodeParticipates && nodes[source].highlighted && nodes[target].highlighted;
      var guiltyLink = source === (highlightedLink && highlightedLink.source) && target === (highlightedLink && highlightedLink.target);
      var highlight = guiltyNode || guiltyLink;
      var opacity = link.opacity || config.link.opacity;
      if (highlightedNode || highlightedLink && highlightedLink.source) {
        opacity = highlight ? config.link.opacity : config.highlightOpacity;
      }
      var stroke = link.color || config.link.color;
      if (highlight) {
        stroke = config.link.highlightColor === _graph["default"].KEYWORDS.SAME ? config.link.color : config.link.highlightColor;
      }
      var strokeDasharray = link.strokeDasharray || config.link.strokeDasharray;
      var strokeDashoffset = link.strokeDashoffset || config.link.strokeDashoffset;
      var strokeLinecap = link.strokeLinecap || config.link.strokeLinecap;
      var strokeWidth = (link.strokeWidth || config.link.strokeWidth) * (1 / transform);
      if (config.link.semanticStrokeWidth) {
        var linkValue = links[source][target] || links[target][source] || 1;
        strokeWidth += linkValue * strokeWidth / 10;
      }
      var markerId = config.directed ? (0, _marker.getMarkerId)(highlight, transform, config) : null;
      var t = 1 / transform;
      var fontSize = null, fontColor = null, fontWeight = null, label = null;
      if (config.link.renderLabel) {
        if (typeof config.link.labelProperty === "function") {
          label = config.link.labelProperty(link);
        } else {
          label = link[config.link.labelProperty];
        }
        fontSize = link.fontSize || config.link.fontSize;
        fontColor = link.fontColor || config.link.fontColor;
        fontWeight = highlight ? config.link.highlightFontWeight : config.link.fontWeight;
      }
      var _getNormalizedNodeCoo = (0, _graph2.getNormalizedNodeCoordinates)({
        sourceId: source,
        targetId: target,
        sourceCoords: {
          x: x1,
          y: y1
        },
        targetCoords: {
          x: x2,
          y: y2
        }
      }, nodes, config, strokeWidth), sourceCoords = _getNormalizedNodeCoo.sourceCoords, targetCoords = _getNormalizedNodeCoo.targetCoords;
      var d = (0, _link.buildLinkPathDefinition)(sourceCoords, targetCoords, type, link.breakPoints);
      return {
        className: _graph["default"].LINK_CLASS_NAME,
        d,
        fontColor,
        fontSize: fontSize * t,
        fontWeight,
        label,
        markerId,
        mouseCursor: config.link.mouseCursor,
        opacity,
        source,
        stroke,
        strokeWidth,
        strokeDasharray,
        strokeDashoffset,
        strokeLinecap,
        target,
        onClickLink: linkCallbacks.onClickLink,
        onMouseOutLink: linkCallbacks.onMouseOutLink,
        onMouseOverLink: linkCallbacks.onMouseOverLink,
        onRightClickLink: linkCallbacks.onRightClickLink
      };
    }
    function buildNodeProps(node, config) {
      var nodeCallbacks = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var highlightedNode = arguments.length > 3 ? arguments[3] : void 0;
      var highlightedLink = arguments.length > 4 ? arguments[4] : void 0;
      var transform = arguments.length > 5 ? arguments[5] : void 0;
      var highlight = node.highlighted || node.id === (highlightedLink && highlightedLink.source) || node.id === (highlightedLink && highlightedLink.target);
      var opacity = _getNodeOpacity(node, highlightedNode, highlightedLink, config);
      var fill = node.color || config.node.color;
      if (highlight && config.node.highlightColor !== _graph["default"].KEYWORDS.SAME) {
        fill = config.node.highlightColor;
      }
      var stroke = node.strokeColor || config.node.strokeColor;
      if (highlight && config.node.highlightStrokeColor !== _graph["default"].KEYWORDS.SAME) {
        stroke = config.node.highlightStrokeColor;
      }
      var label = node[config.node.labelProperty] || node.id;
      if (typeof config.node.labelProperty === "function") {
        label = config.node.labelProperty(node);
      }
      var labelPosition = node.labelPosition || config.node.labelPosition;
      var strokeWidth = node.strokeWidth || config.node.strokeWidth;
      if (highlight && config.node.highlightStrokeWidth !== _graph["default"].KEYWORDS.SAME) {
        strokeWidth = config.node.highlightStrokeWidth;
      }
      var t = 1 / transform;
      var nodeSize = node.size || config.node.size;
      var isSizeNumericValue = _typeof(nodeSize) !== "object";
      var offset = 0;
      if (isSizeNumericValue) {
        offset = nodeSize;
      } else if (labelPosition === "top" || labelPosition === "bottom") {
        offset = nodeSize.height;
      } else if (labelPosition === "right" || labelPosition === "left") {
        offset = nodeSize.width;
      }
      var fontSize = node.fontSize || config.node.fontSize;
      var highlightFontSize = node.highlightFontSize || config.node.highlightFontSize;
      var finalFontSize = highlight ? highlightFontSize : fontSize;
      var dx = finalFontSize * t + offset / 100 + 1.5;
      var svg = node.svg || config.node.svg;
      var fontColor = node.fontColor || config.node.fontColor;
      var renderLabel = config.node.renderLabel;
      if (node.renderLabel !== void 0 && typeof node.renderLabel === "boolean") {
        renderLabel = node.renderLabel;
      }
      return _objectSpread({}, node, {
        className: _graph["default"].NODE_CLASS_NAME,
        cursor: config.node.mouseCursor,
        cx: (node === null || node === void 0 ? void 0 : node.x) || "0",
        cy: (node === null || node === void 0 ? void 0 : node.y) || "0",
        dx,
        fill,
        fontColor,
        fontSize: finalFontSize * t,
        fontWeight: highlight ? config.node.highlightFontWeight : config.node.fontWeight,
        id: node.id,
        label,
        labelPosition,
        opacity,
        overrideGlobalViewGenerator: !node.viewGenerator && node.svg,
        renderLabel,
        size: isSizeNumericValue ? nodeSize * t : {
          height: nodeSize.height * t,
          width: nodeSize.width * t
        },
        stroke,
        strokeWidth: strokeWidth * t,
        svg,
        type: node.symbolType || config.node.symbolType,
        viewGenerator: node.viewGenerator || config.node.viewGenerator,
        onClickNode: nodeCallbacks.onClickNode,
        onMouseOut: nodeCallbacks.onMouseOut,
        onMouseOverNode: nodeCallbacks.onMouseOverNode,
        onRightClickNode: nodeCallbacks.onRightClickNode
      });
    }
  }
});

// node_modules/react-d3-graph/lib/components/graph/graph.renderer.js
var require_graph_renderer = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/graph.renderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.renderGraph = renderGraph;
    var _react = _interopRequireDefault(require_react());
    var _graph = _interopRequireDefault(require_graph_const());
    var _marker = require_marker_const();
    var _Link = _interopRequireDefault(require_Link());
    var _Node = _interopRequireDefault(require_Node());
    var _Marker = _interopRequireDefault(require_Marker());
    var _graph2 = require_graph_builder();
    var _graph3 = require_graph_helper();
    var _collapse = require_collapse_helper();
    var _marker2 = require_marker_helper();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _renderLinks(nodes, links, linksMatrix, config, linkCallbacks, highlightedNode, highlightedLink, transform) {
      var outLinks = links;
      if (config.collapsible) {
        outLinks = outLinks.filter(function(_ref) {
          var isHidden = _ref.isHidden;
          return !isHidden;
        });
      }
      return outLinks.map(function(link) {
        var source = link.source, target = link.target;
        var sourceId = (0, _graph3.getId)(source);
        var targetId = (0, _graph3.getId)(target);
        var key = "".concat(sourceId).concat(_graph["default"].COORDS_SEPARATOR).concat(targetId);
        var props = (0, _graph2.buildLinkProps)(_objectSpread({}, link, {
          source: "".concat(sourceId),
          target: "".concat(targetId)
        }), nodes, linksMatrix, config, linkCallbacks, "".concat(highlightedNode), highlightedLink, transform);
        return _react["default"].createElement(_Link["default"], _extends({
          key,
          id: key
        }, props));
      });
    }
    function _renderNodes(nodes, nodeCallbacks, config, highlightedNode, highlightedLink, transform, linksMatrix) {
      var outNodes = Object.keys(nodes);
      if (config.collapsible) {
        outNodes = outNodes.filter(function(nodeId) {
          return (0, _collapse.isNodeVisible)(nodeId, nodes, linksMatrix);
        });
      }
      return outNodes.map(function(nodeId) {
        var props = (0, _graph2.buildNodeProps)(_objectSpread({}, nodes[nodeId], {
          id: "".concat(nodeId)
        }), config, nodeCallbacks, highlightedNode, highlightedLink, transform);
        return _react["default"].createElement(_Node["default"], _extends({
          key: nodeId
        }, props));
      });
    }
    function _renderDefs() {
      var markerCache = {};
      return function(config) {
        var highlightColor = !config.link.highlightColor || config.link.highlightColor === "SAME" ? config.link.color : config.link.highlightColor;
        var color = config.link.color;
        var key = "".concat(color, "___").concat(highlightColor);
        if (!markerCache[key]) {
          var _getMarkerSize = (0, _marker2.getMarkerSize)(config), small = _getMarkerSize.small, medium = _getMarkerSize.medium, large = _getMarkerSize.large;
          var markerProps = {
            markerWidth: config.link.markerWidth,
            markerHeight: config.link.markerHeight
          };
          markerCache[key] = _react["default"].createElement("defs", null, _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_S,
            refX: small,
            fill: color
          }, markerProps)), _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_SH,
            refX: small,
            fill: highlightColor
          }, markerProps)), _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_M,
            refX: medium,
            fill: color
          }, markerProps)), _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_MH,
            refX: medium,
            fill: highlightColor
          }, markerProps)), _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_L,
            refX: large,
            fill: color
          }, markerProps)), _react["default"].createElement(_Marker["default"], _extends({
            id: _marker.MARKERS.MARKER_LH,
            refX: large,
            fill: highlightColor
          }, markerProps)));
        }
        return markerCache[key];
      };
    }
    var _memoizedRenderDefs = _renderDefs();
    function renderGraph(nodes, nodeCallbacks, links, linksMatrix, linkCallbacks, config, highlightedNode, highlightedLink, transform) {
      return {
        nodes: _renderNodes(nodes, nodeCallbacks, config, highlightedNode, highlightedLink, transform, linksMatrix),
        links: _renderLinks(nodes, links, linksMatrix, config, linkCallbacks, highlightedNode, highlightedLink, transform),
        defs: _memoizedRenderDefs(config)
      };
    }
  }
});

// node_modules/react-d3-graph/lib/components/graph/Graph.js
var require_Graph = __commonJS({
  "node_modules/react-d3-graph/lib/components/graph/Graph.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _d3Drag = (init_src3(), __toCommonJS(src_exports3));
    var _d3Force = (init_src4(), __toCommonJS(src_exports4));
    var _d3Selection = (init_src2(), __toCommonJS(src_exports2));
    var _d3Zoom = (init_src5(), __toCommonJS(src_exports5));
    var _graph = _interopRequireDefault(require_graph_const());
    var _graph2 = _interopRequireDefault(require_graph_config());
    var _err = _interopRequireDefault(require_err());
    var _collapse = require_collapse_helper();
    var _graph3 = require_graph_helper();
    var _graph4 = require_graph_renderer();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _extends() {
      _extends = Object.assign || function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var Graph = function(_React$Component) {
      _inherits(Graph2, _React$Component);
      _createClass(Graph2, [{
        key: "_graphLinkForceConfig",
        /**
         * Obtain a set of properties which will be used to perform the focus and zoom animation if
         * required. In case there's not a focus and zoom animation in progress, it should reset the
         * transition duration to zero and clear transformation styles.
         * @returns {Object} - Focus and zoom animation properties.
         */
        /**
         * This method runs {@link d3-force|https://github.com/d3/d3-force}
         * against the current graph.
         * @returns {undefined}
         */
        value: function _graphLinkForceConfig() {
          var forceLink = (0, _d3Force.forceLink)(this.state.d3Links).id(function(l) {
            return l.id;
          }).distance(this.state.config.d3.linkLength).strength(this.state.config.d3.linkStrength);
          this.state.simulation.force(_graph["default"].LINK_CLASS_NAME, forceLink);
        }
        /**
         * This method runs {@link d3-drag|https://github.com/d3/d3-drag}
         * against the current graph.
         * @returns {undefined}
         */
      }, {
        key: "_graphNodeDragConfig",
        value: function _graphNodeDragConfig() {
          var customNodeDrag = (0, _d3Drag.drag)().on("start", this._onDragStart).on("drag", this._onDragMove).on("end", this._onDragEnd);
          (0, _d3Selection.select)("#".concat(this.state.id, "-").concat(_graph["default"].GRAPH_WRAPPER_ID)).selectAll(".node").call(customNodeDrag);
        }
        /**
         * Sets d3 tick function and configures other d3 stuff such as forces and drag events.
         * Whenever called binds Graph component state with d3.
         * @returns {undefined}
         */
      }, {
        key: "_graphBindD3ToReactComponent",
        value: function _graphBindD3ToReactComponent() {
          if (!this.state.config.d3.disableLinkForce) {
            this.state.simulation.nodes(this.state.d3Nodes).on("tick", this._tick);
            this._graphLinkForceConfig();
          }
          if (!this.state.config.freezeAllDragEvents) {
            this._graphNodeDragConfig();
          }
        }
        /**
         * Handles d3 drag 'end' event.
         * @returns {undefined}
         */
      }]);
      function Graph2(props) {
        var _this;
        _classCallCheck(this, Graph2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(Graph2).call(this, props));
        _defineProperty(_assertThisInitialized(_this), "_generateFocusAnimationProps", function() {
          if (_this.state.enableFocusAnimation) {
            if (_this.focusAnimationTimeout) {
              clearTimeout(_this.focusAnimationTimeout);
            }
            _this.focusAnimationTimeout = setTimeout(function() {
              return _this.setState({
                enableFocusAnimation: false
              });
            }, _this.state.config.focusAnimationDuration * 1e3);
          }
          var transitionDuration = _this.state.enableFocusAnimation ? _this.state.config.focusAnimationDuration : 0;
          return {
            style: {
              transitionDuration: "".concat(transitionDuration, "s")
            },
            transform: _this.state.focusTransformation
          };
        });
        _defineProperty(_assertThisInitialized(_this), "_onDragEnd", function() {
          _this.isDraggingNode = false;
          if (_this.state.draggedNode) {
            _this.onNodePositionChange(_this.state.draggedNode);
            _this._tick({
              draggedNode: null
            });
          }
          !_this.state.config.staticGraph && _this.state.config.automaticRearrangeAfterDropNode && _this.state.simulation.alphaTarget(_this.state.config.d3.alphaTarget).restart();
        });
        _defineProperty(_assertThisInitialized(_this), "_onDragMove", function(ev, index, nodeList) {
          var id = nodeList[index].id;
          if (!_this.state.config.staticGraph) {
            var draggedNode = _this.state.nodes[id];
            draggedNode.oldX = draggedNode.x;
            draggedNode.oldY = draggedNode.y;
            draggedNode.x += _d3Selection.event.dx;
            draggedNode.y += _d3Selection.event.dy;
            draggedNode["fx"] = draggedNode.x;
            draggedNode["fy"] = draggedNode.y;
            _this._tick({
              draggedNode
            });
          }
        });
        _defineProperty(_assertThisInitialized(_this), "_onDragStart", function() {
          _this.isDraggingNode = true;
          _this.pauseSimulation();
          if (_this.state.enableFocusAnimation) {
            _this.setState({
              enableFocusAnimation: false
            });
          }
        });
        _defineProperty(_assertThisInitialized(_this), "_setNodeHighlightedValue", function(id) {
          var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          return _this._tick((0, _graph3.updateNodeHighlightedValue)(_this.state.nodes, _this.state.links, _this.state.config, id, value));
        });
        _defineProperty(_assertThisInitialized(_this), "_tick", function() {
          var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          var cb = arguments.length > 1 ? arguments[1] : void 0;
          return cb ? _this.setState(state, cb) : _this.setState(state);
        });
        _defineProperty(_assertThisInitialized(_this), "_zoomConfig", function() {
          var selector = (0, _d3Selection.select)("#".concat(_this.state.id, "-").concat(_graph["default"].GRAPH_WRAPPER_ID));
          var zoomObject = (0, _d3Zoom.zoom)().scaleExtent([_this.state.config.minZoom, _this.state.config.maxZoom]);
          if (!_this.state.config.freezeAllDragEvents) {
            zoomObject.on("zoom", _this._zoomed);
          }
          if (_this.state.config.initialZoom !== null) {
            zoomObject.scaleTo(selector, _this.state.config.initialZoom);
          }
          selector.call(zoomObject).on("dblclick.zoom", null);
        });
        _defineProperty(_assertThisInitialized(_this), "_zoomed", function() {
          var transform = _d3Selection.event.transform;
          (0, _d3Selection.selectAll)("#".concat(_this.state.id, "-").concat(_graph["default"].GRAPH_CONTAINER_ID)).attr("transform", transform);
          _this.state.config.panAndZoom && _this.setState({
            transform: transform.k
          });
          if (_this.debouncedOnZoomChange && _this.state.previousZoom !== transform.k) {
            _this.debouncedOnZoomChange(_this.state.previousZoom, transform.k);
            _this.setState({
              previousZoom: transform.k
            });
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onClickGraph", function(e) {
          var _e$target, _e$target$attributes, _e$target$attributes$;
          if (_this.state.enableFocusAnimation) {
            _this.setState({
              enableFocusAnimation: false
            });
          }
          var tagName = e.target && e.target.tagName;
          var name = e === null || e === void 0 ? void 0 : (_e$target = e.target) === null || _e$target === void 0 ? void 0 : (_e$target$attributes = _e$target.attributes) === null || _e$target$attributes === void 0 ? void 0 : (_e$target$attributes$ = _e$target$attributes.name) === null || _e$target$attributes$ === void 0 ? void 0 : _e$target$attributes$.value;
          var svgContainerName = "svg-container-".concat(_this.state.id);
          if (tagName.toUpperCase() === "SVG" && name === svgContainerName) {
            _this.props.onClickGraph && _this.props.onClickGraph(e);
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onClickNode", function(clickedNodeId) {
          var clickedNode = _this.state.nodes[clickedNodeId];
          if (_this.state.config.collapsible) {
            var leafConnections = (0, _collapse.getTargetLeafConnections)(clickedNodeId, _this.state.links, _this.state.config);
            var links = (0, _collapse.toggleLinksMatrixConnections)(_this.state.links, leafConnections, _this.state.config);
            var d3Links = (0, _collapse.toggleLinksConnections)(_this.state.d3Links, links);
            var firstLeaf = leafConnections === null || leafConnections === void 0 ? void 0 : leafConnections["0"];
            var isExpanding = false;
            if (firstLeaf) {
              var visibility = links[firstLeaf.source][firstLeaf.target];
              isExpanding = visibility === 1;
            }
            _this._tick({
              links,
              d3Links
            }, function() {
              _this.props.onClickNode && _this.props.onClickNode(clickedNodeId, clickedNode);
              if (isExpanding) {
                _this._graphNodeDragConfig();
              }
            });
          } else {
            if (!_this.nodeClickTimer) {
              _this.nodeClickTimer = setTimeout(function() {
                _this.props.onClickNode && _this.props.onClickNode(clickedNodeId, clickedNode);
                _this.nodeClickTimer = null;
              }, _graph["default"].TTL_DOUBLE_CLICK_IN_MS);
            } else {
              _this.props.onDoubleClickNode && _this.props.onDoubleClickNode(clickedNodeId, clickedNode);
              _this.nodeClickTimer = clearTimeout(_this.nodeClickTimer);
            }
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onRightClickNode", function(event, id) {
          var clickedNode = _this.state.nodes[id];
          _this.props.onRightClickNode && _this.props.onRightClickNode(event, id, clickedNode);
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseOverNode", function(id) {
          if (_this.isDraggingNode) {
            return;
          }
          var clickedNode = _this.state.nodes[id];
          _this.props.onMouseOverNode && _this.props.onMouseOverNode(id, clickedNode);
          _this.state.config.nodeHighlightBehavior && _this._setNodeHighlightedValue(id, true);
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseOutNode", function(id) {
          if (_this.isDraggingNode) {
            return;
          }
          var clickedNode = _this.state.nodes[id];
          _this.props.onMouseOutNode && _this.props.onMouseOutNode(id, clickedNode);
          _this.state.config.nodeHighlightBehavior && _this._setNodeHighlightedValue(id, false);
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseOverLink", function(source, target) {
          _this.props.onMouseOverLink && _this.props.onMouseOverLink(source, target);
          if (_this.state.config.linkHighlightBehavior) {
            var highlightedLink = {
              source,
              target
            };
            _this._tick({
              highlightedLink
            });
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onMouseOutLink", function(source, target) {
          _this.props.onMouseOutLink && _this.props.onMouseOutLink(source, target);
          if (_this.state.config.linkHighlightBehavior) {
            var highlightedLink = void 0;
            _this._tick({
              highlightedLink
            });
          }
        });
        _defineProperty(_assertThisInitialized(_this), "onNodePositionChange", function(node) {
          if (!_this.props.onNodePositionChange) {
            return;
          }
          var id = node.id, x = node.x, y = node.y;
          _this.props.onNodePositionChange(id, x, y);
        });
        _defineProperty(_assertThisInitialized(_this), "pauseSimulation", function() {
          return _this.state.simulation.stop();
        });
        _defineProperty(_assertThisInitialized(_this), "resetNodesPositions", function() {
          if (!_this.state.config.staticGraph) {
            var initialNodesState = (0, _graph3.initializeNodes)(_this.props.data.nodes);
            for (var nodeId in _this.state.nodes) {
              var node = _this.state.nodes[nodeId];
              if (node.fx && node.fy) {
                Reflect.deleteProperty(node, "fx");
                Reflect.deleteProperty(node, "fy");
              }
              if (nodeId in initialNodesState) {
                var initialNode = initialNodesState[nodeId];
                node.x = initialNode.x;
                node.y = initialNode.y;
              }
            }
            _this.state.simulation.alphaTarget(_this.state.config.d3.alphaTarget).restart();
            _this._tick();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "restartSimulation", function() {
          return !_this.state.config.staticGraph && _this.state.simulation.restart();
        });
        if (!_this.props.id) {
          (0, _utils.throwErr)(_this.constructor.name, _err["default"].GRAPH_NO_ID_PROP);
        }
        _this.focusAnimationTimeout = null;
        _this.nodeClickTimer = null;
        _this.isDraggingNode = false;
        _this.state = (0, _graph3.initializeGraphState)(_this.props, _this.state);
        _this.debouncedOnZoomChange = _this.props.onZoomChange ? (0, _utils.debounce)(_this.props.onZoomChange, 100) : null;
        return _this;
      }
      _createClass(Graph2, [{
        key: "UNSAFE_componentWillReceiveProps",
        value: function UNSAFE_componentWillReceiveProps(nextProps) {
          var _checkForGraphElement = (0, _graph3.checkForGraphElementsChanges)(nextProps, this.state), graphElementsUpdated = _checkForGraphElement.graphElementsUpdated, newGraphElements = _checkForGraphElement.newGraphElements;
          var state = graphElementsUpdated ? (0, _graph3.initializeGraphState)(nextProps, this.state) : this.state;
          var newConfig = nextProps.config || {};
          var _checkForGraphConfigC = (0, _graph3.checkForGraphConfigChanges)(nextProps, this.state), configUpdated = _checkForGraphConfigC.configUpdated, d3ConfigUpdated = _checkForGraphConfigC.d3ConfigUpdated;
          var config = configUpdated ? (0, _utils.merge)(_graph2["default"], newConfig) : this.state.config;
          newGraphElements && this.pauseSimulation();
          var transform = newConfig.panAndZoom !== this.state.config.panAndZoom ? 1 : this.state.transform;
          var focusedNodeId = nextProps.data.focusedNodeId;
          var d3FocusedNode = this.state.d3Nodes.find(function(node) {
            return "".concat(node.id) === "".concat(focusedNodeId);
          });
          var containerElId = "".concat(this.state.id, "-").concat(_graph["default"].GRAPH_WRAPPER_ID);
          var focusTransformation = (0, _graph3.getCenterAndZoomTransformation)(d3FocusedNode, this.state.config, containerElId) || this.state.focusTransformation;
          var enableFocusAnimation = this.props.data.focusedNodeId !== nextProps.data.focusedNodeId;
          if (nextProps.onZoomChange) {
            this.debouncedOnZoomChange = (0, _utils.debounce)(nextProps.onZoomChange, 100);
          }
          this.setState(_objectSpread({}, state, {
            config,
            configUpdated,
            d3ConfigUpdated,
            newGraphElements,
            transform,
            focusedNodeId,
            enableFocusAnimation,
            focusTransformation
          }));
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate() {
          var shouldPause = this.state.config.staticGraph || this.state.config.staticGraphWithDragAndDrop;
          if (shouldPause) {
            this.pauseSimulation();
          }
          if (!this.state.config.staticGraph && (this.state.newGraphElements || this.state.d3ConfigUpdated)) {
            this._graphBindD3ToReactComponent();
            if (!this.state.config.staticGraphWithDragAndDrop) {
              this.restartSimulation();
            }
            this.setState({
              newGraphElements: false,
              d3ConfigUpdated: false
            });
          } else if (this.state.configUpdated) {
            this._graphNodeDragConfig();
          }
          if (this.state.configUpdated) {
            this._zoomConfig();
            this.setState({
              configUpdated: false
            });
          }
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          if (!this.state.config.staticGraph) {
            this._graphBindD3ToReactComponent();
          }
          this._zoomConfig();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.pauseSimulation();
          if (this.nodeClickTimer) {
            clearTimeout(this.nodeClickTimer);
            this.nodeClickTimer = null;
          }
          if (this.focusAnimationTimeout) {
            clearTimeout(this.focusAnimationTimeout);
            this.focusAnimationTimeout = null;
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _renderGraph = (0, _graph4.renderGraph)(this.state.nodes, {
            onClickNode: this.onClickNode,
            onDoubleClickNode: this.onDoubleClickNode,
            onRightClickNode: this.onRightClickNode,
            onMouseOverNode: this.onMouseOverNode,
            onMouseOut: this.onMouseOutNode
          }, this.state.d3Links, this.state.links, {
            onClickLink: this.props.onClickLink,
            onRightClickLink: this.props.onRightClickLink,
            onMouseOverLink: this.onMouseOverLink,
            onMouseOutLink: this.onMouseOutLink
          }, this.state.config, this.state.highlightedNode, this.state.highlightedLink, this.state.transform), nodes = _renderGraph.nodes, links = _renderGraph.links, defs = _renderGraph.defs;
          var svgStyle = {
            height: this.state.config.height,
            width: this.state.config.width
          };
          var containerProps = this._generateFocusAnimationProps();
          return _react["default"].createElement("div", {
            id: "".concat(this.state.id, "-").concat(_graph["default"].GRAPH_WRAPPER_ID)
          }, _react["default"].createElement("svg", {
            name: "svg-container-".concat(this.state.id),
            style: svgStyle,
            onClick: this.onClickGraph
          }, defs, _react["default"].createElement("g", _extends({
            id: "".concat(this.state.id, "-").concat(_graph["default"].GRAPH_CONTAINER_ID)
          }, containerProps), links, nodes)));
        }
      }]);
      return Graph2;
    }(_react["default"].Component);
    exports["default"] = Graph;
  }
});

// node_modules/react-d3-graph/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-d3-graph/lib/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Graph", {
      enumerable: true,
      get: function get() {
        return _Graph["default"];
      }
    });
    Object.defineProperty(exports, "Node", {
      enumerable: true,
      get: function get() {
        return _Node["default"];
      }
    });
    Object.defineProperty(exports, "Link", {
      enumerable: true,
      get: function get() {
        return _Link["default"];
      }
    });
    var _Graph = _interopRequireDefault(require_Graph());
    var _Node = _interopRequireDefault(require_Node());
    var _Link = _interopRequireDefault(require_Link());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
  }
});
export default require_lib();
//# sourceMappingURL=react-d3-graph.js.map
